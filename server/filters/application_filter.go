package filters

import (
	"encoding/json"
	"fmt"
	"github.com/flosch/pongo2"
	_ "github.com/flosch/pongo2-addons"
	"github.com/h3poteto/fascia/config"
	_ "github.com/russross/blackfriday" // pongo2-addonsが依存するblackfridayが古いため明示的な依存を書く必要がある
	"io/ioutil"
	"os"
	"path/filepath"
	"strconv"
	"syscall"
)

// SuffixAssetsUpdate add suffix from timestamp at asset file path.
func SuffixAssetsUpdate(in *pongo2.Value, param *pongo2.Value) (out *pongo2.Value, err *pongo2.Error) {
	assetsFile, ok := in.Interface().(string)
	if !ok {
		return nil, &pongo2.Error{
			Sender:    "suffixStylesheet",
			OrigError: fmt.Errorf("Data must be string %T ('%v')", in, in),
		}
	}

	var file syscall.Stat_t
	syscall.Stat("./public/assets"+assetsFile, &file)
	timestamp, _ := file.Mtim.Unix()
	return pongo2.AsValue(assetsFile + "?update=" + strconv.FormatInt(timestamp, 10)), nil
}

// DigestedAssets returns digested asset file path based on manifest.json.
func DigestedAssets(in *pongo2.Value, param *pongo2.Value) (out *pongo2.Value, err *pongo2.Error) {
	assetsFile, ok := in.Interface().(string)
	if !ok {
		return nil, &pongo2.Error{
			Sender:    "digestedAssets",
			OrigError: fmt.Errorf("Data must be string %T ('%v')", in, in),
		}
	}

	// Parse a manifest.json which is generated by webpack, and get digested asset file name.
	root := os.Getenv("APPROOT")
	path := filepath.Join(root, "./public/assets/manifest.json")
	buf, e := ioutil.ReadFile(path)
	if e != nil {
		return nil, &pongo2.Error{
			Sender:    "suffixStylesheet",
			OrigError: e,
		}
	}
	manifest := make(map[string]interface{})
	e = json.Unmarshal(buf, &manifest)
	if e != nil {
		return nil, &pongo2.Error{
			Sender:    "suffixStylesheet",
			OrigError: e,
		}
	}

	// nilの場合は積極的にエラーにして落としたい
	digested := manifest[assetsFile].(string)

	assetHost := config.Element("asset_host").(string)
	return pongo2.AsValue(assetHost + digested), nil
}
